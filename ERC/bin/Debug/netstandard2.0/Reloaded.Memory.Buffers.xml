<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Reloaded.Memory.Buffers</name>
    </assembly>
    <members>
        <member name="M:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.IsWow64Process(System.IntPtr,System.Boolean@)">
            <summary>Determines whether the specified process is running under WOW64.</summary>
            <param name="hProcess">
            <para>
            A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information,
            see Process Security and Access Rights.
            </para>
            <para><c>Windows Server 2003 and Windows XP:</c> The handle must have the PROCESS_QUERY_INFORMATION access right.</para>
            </param>
            <param name="Wow64Process">
            A pointer to a value that is set to TRUE if the process is running under WOW64. If the process is running under 32-bit Windows, the value is set to
            FALSE. If the process is a 64-bit application running under 64-bit Windows, the value is also set to FALSE.
            </param>
            <returns>
            <para>If the function succeeds, the return value is a nonzero value.</para>
            <para>If the function fails, the return value is zero. To get extended error information, call <c>GetLastError</c>.</para>
            </returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.GetSystemInfo(Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO@)">
            <summary>
            <para>Retrieves information about the current system.</para>
            <para>To retrieve accurate information for an application running on WOW64, call the <c>GetNativeSystemInfo</c> function.</para>
            </summary>
            <param name="lpSystemInfo">A pointer to a <c>SYSTEM_INFO</c> structure that receives the information.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO">
            <summary>
            Contains information about the current computer system. This includes the architecture and type of the processor, the number of
            processors in the system, the page size, and other such information.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.wProcessorArchitecture">
            <summary>
            <para>The processor architecture of the installed operating system. This member can be one of the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PROCESSOR_ARCHITECTURE_AMD649</term>
            <term>x64 (AMD or Intel)</term>
            </item>
            <item>
            <term>PROCESSOR_ARCHITECTURE_ARM5</term>
            <term>ARM</term>
            </item>
            <item>
            <term>PROCESSOR_ARCHITECTURE_ARM6412</term>
            <term>ARM64</term>
            </item>
            <item>
            <term>PROCESSOR_ARCHITECTURE_IA646</term>
            <term>Intel Itanium-based</term>
            </item>
            <item>
            <term>PROCESSOR_ARCHITECTURE_INTEL0</term>
            <term>x86</term>
            </item>
            <item>
            <term>PROCESSOR_ARCHITECTURE_UNKNOWN0xffff</term>
            <term>Unknown architecture.</term>
            </item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.wReserved">
            <summary>This member is reserved for future use.</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.dwPageSize">
            <summary>
            The page size and the granularity of page protection and commitment. This is the page size used by the <c>VirtualAlloc</c> function.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.lpMinimumApplicationAddress">
            <summary>A pointer to the lowest memory address accessible to applications and dynamic-link libraries (DLLs).</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.lpMaximumApplicationAddress">
            <summary>A pointer to the highest memory address accessible to applications and DLLs.</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.dwActiveProcessorMask">
            <summary>
            A mask representing the set of processors configured into the system. Bit 0 is processor 0; bit 31 is processor 31.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.dwNumberOfProcessors">
            <summary>
            The number of logical processors in the current group. To retrieve this value, use the <c>GetLogicalProcessorInformation</c> function.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.dwProcessorType">
            <summary>
            An obsolete member that is retained for compatibility. Use the <c>wProcessorArchitecture</c>, <c>wProcessorLevel</c>, and
            <c>wProcessorRevision</c> members to determine the type of processor.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.dwAllocationGranularity">
            <summary>
            The granularity for the starting address at which virtual memory can be allocated. For more information, see <c>VirtualAlloc</c>.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.wProcessorLevel">
            <summary>
            <para>
            The architecture-dependent processor level. It should be used only for display purposes. To determine the feature set of a
            processor, use the <c>IsProcessorFeaturePresent</c> function.
            </para>
            <para>If <c>wProcessorArchitecture</c> is PROCESSOR_ARCHITECTURE_INTEL, <c>wProcessorLevel</c> is defined by the CPU vendor.</para>
            <para>If <c>wProcessorArchitecture</c> is PROCESSOR_ARCHITECTURE_IA64, <c>wProcessorLevel</c> is set to 1.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.SYSTEM_INFO.wProcessorRevision">
            <summary>
            <para>
            The architecture-dependent processor revision. The following table shows how the revision value is assembled for each type of
            processor architecture.
            </para>
            <para>
            <list type="table">
            <listheader>
            <term>Processor</term>
            <term>Value</term>
            </listheader>
            <item>
            <term>Intel Pentium, Cyrix, or NextGen 586</term>
            <term>
            The high byte is the model and the low byte is the stepping. For example, if the value is xxyy, the model number and stepping
            can be displayed as
            follows: Model xx, Stepping yy
            </term>
            </item>
            <item>
            <term>Intel 80386 or 80486</term>
            <term>
            A value of the form xxyz. If xx is equal to 0xFF, y - 0xA is the model number, and z is the stepping identifier.If xx is not
            equal to 0xFF, xx + 'A' is the stepping letter and yz is the minor stepping.
            </term>
            </item>
            <item>
            <term>ARM</term>
            <term>Reserved.</term>
            </item>
            </list>
            </para>
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION">
            <summary>
            <para>
            Contains information about a range of pages in the virtual address space of a process. The VirtualQuery and VirtualQueryEx
            functions use this structure.
            </para>
            </summary>
            <remarks>
            <para>
            To enable a debugger to debug a target that is running on a different architecture (32-bit versus 64-bit), use one of the
            explicit forms of this structure.
            </para>
            </remarks>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION.BaseAddress">
            <summary>
            <para>A pointer to the base address of the region of pages.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION.AllocationBase">
            <summary>
            <para>
            A pointer to the base address of a range of pages allocated by the VirtualAlloc function. The page pointed to by the
            <c>BaseAddress</c> member is contained within this allocation range.
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION.AllocationProtect">
            <summary>
            <para>
            The memory protection option when the region was initially allocated. This member can be one of the memory protection
            constants or 0 if the caller does not have access.
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION.RegionSize">
            <summary>
            <para>The size of the region beginning at the base address in which all pages have identical attributes, in bytes.</para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION.State">
            <summary>
            <para>The state of the pages in the region. This member can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>State</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_COMMIT 0x1000</term>
            <term>
            Indicates committed pages for which physical storage has been allocated, either in memory or in the paging file on disk.
            </term>
            </item>
            <item>
            <term>MEM_FREE 0x10000</term>
            <term>
            Indicates free pages not accessible to the calling process and available to be allocated. For free pages, the information in
            the AllocationBase, AllocationProtect, Protect, and Type members is undefined.
            </term>
            </item>
            <item>
            <term>MEM_RESERVE 0x2000</term>
            <term>
            Indicates reserved pages where a range of the process's virtual address space is reserved without any physical storage being
            allocated. For reserved pages, the information in the Protect member is undefined.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION.Protect">
            <summary>
            <para>
            The access protection of the pages in the region. This member is one of the values listed for the <c>AllocationProtect</c> member.
            </para>
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION.Type">
            <summary>
            <para>The type of pages in the region. The following types are defined.</para>
            <list type="table">
            <listheader>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEM_IMAGE 0x1000000</term>
            <term>Indicates that the memory pages within the region are mapped into the view of an image section.</term>
            </item>
            <item>
            <term>MEM_MAPPED 0x40000</term>
            <term>Indicates that the memory pages within the region are mapped into the view of a section.</term>
            </item>
            <item>
            <term>MEM_PRIVATE 0x20000</term>
            <term>Indicates that the memory pages within the region are private (that is, not shared by other processes).</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture">
            <summary>Processor architecture</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_INTEL">
            <summary>x86</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_MIPS">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_ALPHA">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_PPC">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_SHX">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_ARM">
            <summary>ARM</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_IA64">
            <summary>Intel Itanium-based</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_ALPHA64">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_MSIL">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_AMD64">
            <summary>x64 (AMD or Intel)</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_IA32_ON_WIN64">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_NEUTRAL">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_ARM64">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64">
            <summary>Unspecified</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_UNKNOWN">
            <summary>Unknown architecture.</summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory">
            <summary>
            Creates <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s in unmanaged memory and returns a new instance to the user.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.BufferOverhead">
            <summary> Calculates the overhead of each individual buffer.</summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.PrivateBufferOverhead">
            <summary> Calculates the overhead of each individual private buffer.</summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory._bufferMagic">
            <summary> Pregenerated byte sequence used to identify a Reloaded buffer. </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.CreateBuffer(System.Diagnostics.Process,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Creates a new buffer in a specified location in memory with a specified size.
            </summary>
            <param name="process">The process inside which the <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> will be allocated.</param>
            <param name="bufferAddress">Base address of the new buffer to be created. </param>
            <param name="allocationSize">The amount of bytes allocated at bufferAddress</param>
            <param name="allocateMemory">Set this to false if the allocationSize bytes have already been preallocated at bufferAddress.</param>
            <remarks>
            This constructor will override any existing buffer! Please use <see cref="M:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.FromAddress(System.Diagnostics.Process,System.IntPtr)"/> instead
            if you wish to get a hold of an already existing buffer at the given bufferAddress.
            </remarks>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.CreatePrivateBuffer(System.Diagnostics.Process,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Creates a new private <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> in a specified location in memory with a specified size.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.FromAddress(System.Diagnostics.Process,System.IntPtr)">
            <summary>
            Attempts to find an existing <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> at the specified address and returns an instance of it.
            If the operation fails; the function returns null.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.AllocateBuffer(System.Diagnostics.Process,System.IntPtr,System.Int32)">
            <summary>
            Allocates memory to store a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s inside the target process/
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.GetMemorySource(System.Diagnostics.Process)">
            <summary>
            Retrieves the correct <see cref="T:Reloaded.Memory.Sources.IMemory"/> implementation to access the memory of a given
            process.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory.IsBuffer(System.Diagnostics.Process,System.IntPtr)">
            <summary>
            Checks if a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> exists at this location by comparing the bytes available here
            against the MemoryBuffer "Magic".
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher">
            <summary>
            Utility class which searches for existing <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s
            in a process with support for caching already found buffers.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher._bufferCache">
            <summary> Maintains address to buffer mappings. </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher._process">
            <summary> The process in which the buffers are being searched for. </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher.#ctor(System.Diagnostics.Process)">
            <summary>
            Creates a <see cref="T:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher"/> that can search for
            existing Reloaded <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s within a given <see cref="T:System.Diagnostics.Process"/>.
            </summary>
            <param name="targetProcess">The process in which to search for buffers.</param>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher.AddBuffer(Reloaded.Memory.Buffers.MemoryBuffer)">
            <summary>
            Adds a new <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> to the internal buffer cache.
            </summary>
            <param name="buffer">The buffer which to add to cache.</param>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher.FindBuffers">
            <summary>
            Scans the whole process for buffers and returns a list of found buffers.
            </summary>
            <remarks>Running this function updates the internal module cache.</remarks>
            <returns>A list of available <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s to be used.</returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher.GetBuffers(System.Int32,System.Boolean)">
            <summary>
            Returns a list of buffers that satisfy the passed in size requirements.
            </summary>
            <param name="size">The amount of bytes a buffer must have minimum.</param>
            <param name="useCache">
                If this flag is set to true, the searcher will try to return a buffer in its cached list of buffers.
                If one or more buffer meeting the size requirements is found in the cache, an array of found buffers will be returned.
                If no buffer has been found in the cache, the function will scan the whole process for buffers and return the found
                set of buffers which satisfy the size parameter.
            However this may not find the buffers that have been added since the last time this function has called.</param>
            <returns></returns>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Structs.AddressRange">
            <summary>
            Defines a physical address range with a minimum and maximum address.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Structs.AddressRange.Contains(Reloaded.Memory.Buffers.Internal.Structs.AddressRange@)">
            <summary>
            Returns true if the other address range is completely inside
            the current address range.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Structs.AddressRange.Overlaps(Reloaded.Memory.Buffers.Internal.Structs.AddressRange@)">
            <summary>
            Returns true if the other address range intersects another address range, i.e.
            start or end of this range falls inside other range.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Structs.AddressRange.PointInRange(Reloaded.Memory.Buffers.Internal.Structs.AddressRange@,System.Int64)">
            <summary>
            Returns true if a number "point", is between min and max of address range.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Structs.BufferAllocationProperties">
            <summary>
            Stores the properties which define a buffer allocation; i.e. where memory can be allocated.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Structs.BufferAllocationProperties.MemoryAddress">
            <summary> The address of where memory may be allocated. </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Structs.BufferAllocationProperties.Size">
            <summary> The amount of bytes it is possible to allocate. </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Structs.BufferAllocationProperties.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:Reloaded.Memory.Buffers.Internal.Structs.BufferAllocationProperties"/>.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic">
            <summary>
            Sits at the top of every Reloaded buffer and identifies the buffer as Reloaded managed.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic.InitialSeed">
            <summary>
            The initial value from which the pseudo-random sequence is generated.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic.MagicCount">
            <summary>
            Contains the amount of integers used to store the header.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic.ReloadedIdentifier">
            <summary>
            Standard pseudo-random generated signature to mark the start of a Reloaded buffer.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic.#ctor(System.Boolean)">
            <summary>
            Generates a new buffer "magic" header; of size 256 bytes.
            </summary>
            <param name="initialize">Set this to true to create and calculate magic bytes.</param>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic.MagicEquals(Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic@)">
            <summary>
            Returns true if two of the magic sequences inside the structure are equivalent.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Structs.MemoryBufferMagic.PseudoGenerate">
            <summary>
            Generates a pseudo random set of bytes in the place of "Magic".
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Testing.Buffers">
            <summary>
            FOR TESTING USE ONLY, PLEASE DO NOT USE.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Testing.Buffers.FreeBuffer(Reloaded.Memory.Buffers.MemoryBuffer)">
            <summary>
            [FOR TESTING USE ONLY]
            Frees the region of pages that backs an individual <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>.
            </summary>
            <param name="buffer">The buffer to free.</param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Utilities.Mathematics.RoundUp(System.Int32,System.Int32)">
            <summary>
            Rounds up a specified number to the next multiple of X.
            </summary>
            <param name="number">The number to round up.</param>
            <param name="multiple">The multiple the number should be rounded to.</param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Utilities.Mathematics.RoundUp(System.Int64,System.Int64)">
            <summary>
            Rounds up a specified number to the next multiple of X.
            </summary>
            <param name="number">The number to round up.</param>
            <param name="multiple">The multiple the number should be rounded to.</param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Utilities.Mathematics.RoundDown(System.Int64,System.Int64)">
            <summary>
            Rounds up a specified number to the previous multiple of X.
            </summary>
            <param name="number">The number to round down.</param>
            <param name="multiple">The multiple the number should be rounded to.</param>
            <returns></returns>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Utilities.VirtualAllocUtility">
            <summary/>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Utilities.VirtualAllocUtility.VirtualAllocFunction">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Utilities.VirtualAllocUtility.GetVirtualAllocFunction(System.Diagnostics.Process)">
            <summary>
            Retrieves the function to use in place of VirtualAlloc.
            Returns VirtualAlloc if target is same process; else VirtualAllocEx
            </summary>
            <param name="targetProcess">The process which the VirtualAlloc call intends to target.</param>
            <returns>A delegate implementation of <see cref="T:Reloaded.Memory.Buffers.Internal.Utilities.VirtualAllocUtility.VirtualAllocFunction"/></returns>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Utilities.VirtualQueryUtility">
            <summary/>
        </member>
        <member name="T:Reloaded.Memory.Buffers.Internal.Utilities.VirtualQueryUtility.VirtualQueryFunction">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Buffers.Internal.Utilities.VirtualQueryUtility.GetVirtualQueryFunction(System.Diagnostics.Process)">
            <summary>
            Retrieves the function to use in place of VirtualQuery.
            Returns VirtualQuery if target is same process; else VirtualQueryEx
            </summary>
            <param name="targetProcess">The process which the VirtualQuery call intends to target.</param>
            <returns>A delegate implementation of <see cref="T:Reloaded.Memory.Buffers.Internal.Utilities.VirtualQueryUtility.VirtualQueryFunction"/></returns>
        </member>
        <member name="T:Reloaded.Memory.Buffers.MemoryBuffer">
            <summary>
            Provides a buffer for permanent (until the process dies) general small size memory storage, reusable 
            concurrently between different DLLs within the same process.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.MemoryBuffer._bufferAddMutex">
            <summary>
            Stores the reference to a system-wide mutex which prevents concurrent access
            modifying/adding elements of the <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBuffer.MemorySource">
            <summary> Defines where Memory will be read in or written to. </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBuffer.Properties">
            <summary> Gets/Sets the header/properties of the buffer stored in unmanaged memory. </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.MemoryBuffer._headerAddress">
            <summary> Stores the location of the <see cref="T:Reloaded.Memory.Buffers.MemoryBufferProperties"/> structure. </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.SetupMutex(System.Diagnostics.Process)">
            <summary>
            Sets up the mutex to be used by this instance of the <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>.
            The factory methods in <see cref="T:Reloaded.Memory.Buffers.Internal.MemoryBufferFactory"/> SHOULD call this method.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.GetMutexName(System.Diagnostics.Process)">
            <summary>
            Generates the name of the named system-wide mutex for this class.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.Add(System.Byte[],System.Int32)">
            <summary>
            Writes your own memory bytes into process' memory and gives you the address
            for the memory location of the written bytes.
            </summary>
            <param name="bytesToWrite">Individual bytes to be written onto the buffer.</param>
            <param name="alignment">The memory alignment of the item to be added to the buffer.</param>
            <returns>Pointer to the passed in bytes written to memory. Null pointer, if it cannot fit into the buffer.</returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.Add``1(``0@,System.Boolean,System.Int32)">
            <summary>
            Writes your own structure address into process' memory and gives you the address 
            to which the structure has been directly written to.
            </summary>
            <param name="bytesToWrite">A structure to be converted into individual bytes to be written onto the buffer.</param>
            <param name="marshalElement">Set this to true to marshal the given parameter before writing it to the buffer, else false.</param>
            <param name="alignment">The memory alignment of the item to be added to the buffer.</param>
            <returns>Pointer to the newly written structure in memory. Null pointer, if it cannot fit into the buffer.</returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.CanItemFit(System.Int32)">
            <summary>
            Returns true if the object can fit into the buffer, else false.
            </summary>
            <param name="objectSize">The size of the object to be appended to the buffer.</param>
            <returns>Returns true if the object can fit into the buffer, else false.</returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.CanItemFit``1(``0@,System.Boolean)">
            <summary>
            Returns true if the object can fit into the buffer, else false.
            </summary>
            <param name="item">The item to check if it can fit into the buffer.</param>
            <param name="marshalElement">True if the item is to be marshalled, else false.</param>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBuffer.AllocationAddress">
            <summary>
            [Testing use only]
            The address where the individual buffer has been allocated.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.Equals(System.Object)">
            <summary/>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBuffer.GetHashCode">
            <summary/>
        </member>
        <member name="T:Reloaded.Memory.Buffers.MemoryBufferHelper">
            <summary>
            Provides a a way to detect individual Reloaded buffers inside a process used for general small size memory storage,
            adding buffer information within certain proximity of an address as well as other various utilities partaining to
            buffers.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.MemoryBufferHelper._threadLock">
            <summary> Attempts to mitigate synchronization issues by locking the thread creating a new buffer. </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.MemoryBufferHelper.DefaultPageSize">
            <summary> Contains the default size of memory pages to be allocated. </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.MemoryBufferHelper._pageCache">
            <summary> Contains all of the memory pages found in the last scan through the target process. </summary>
        </member>
        <member name="F:Reloaded.Memory.Buffers.MemoryBufferHelper._bufferSearcher">
            <summary> Implementation of the Searcher that scans and finds existing <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s within the current process. </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBufferHelper.Process">
            <summary> The process on which the MemoryBuffer acts upon. </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.#ctor(System.Diagnostics.Process)">
            <summary>
            Creates a new <see cref="T:Reloaded.Memory.Buffers.MemoryBufferHelper"/> for the specified process.
            </summary>
            <param name="process">The process.</param>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.FindBufferLocation(System.Int32,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Finds an appropriate location where a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>;
            or other memory allocation could be performed.
            </summary>
            <param name = "size" > The space in bytes that the specific <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> would require to accomodate.</param>
            <param name="minimumAddress">The minimum absolute address to find a buffer in.</param>
            <param name="maximumAddress">The maximum absolute address to find a buffer in.</param>
            <param name="isPrivateBuffer">Defines whether the buffer type created is a shared or private buffer.</param>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.CreateMemoryBuffer(System.Int32,System.Int64,System.Int64,System.Int32)">
            <summary>
            Creates a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> that satisfies a set size constraint
            and proximity to a set address.
            </summary>
            <param name="size">The minimum size the <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> will have to accomodate.</param>
            <param name="minimumAddress">The minimum absolute address to create a buffer in.</param>
            <param name="maximumAddress">The maximum absolute address to create a buffer in.</param>
            <param name="retryCount">In the case the memory allocation fails; the amount of times memory allocation is to be retried.</param>
            <exception cref="T:System.Exception">Memory allocation failure due to possible race condition with other process/process itself/Windows scheduling.</exception>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.CreatePrivateMemoryBuffer(System.Int32,System.Int64,System.Int64,System.Int32)">
            <summary>
            Creates a <see cref="T:Reloaded.Memory.Buffers.PrivateMemoryBuffer"/> that satisfies a set size constraint and proximity to a set address.
            </summary>
            <param name="size">The minimum size the <see cref="T:Reloaded.Memory.Buffers.PrivateMemoryBuffer"/> will have to accomodate.</param>
            <param name="minimumAddress">The minimum absolute address to create a buffer in.</param>
            <param name="maximumAddress">The maximum absolute address to create a buffer in.</param>
            <param name="retryCount">In the case the memory allocation fails; the amount of times memory allocation is to be retried.</param>
            <exception cref="T:System.Exception">Memory allocation failure due to possible race condition with other process/process itself/Windows scheduling.</exception>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.FindBuffers(System.Int32,System.Boolean)">
            <summary>
            Searches unmanaged memory for pre-existing <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s that satisfy
            the given size requirements.
            </summary>
            <param name="size">The amount of bytes a buffer must have minimum.</param>
            <param name="useCache">See <see cref="M:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher.GetBuffers(System.Int32,System.Boolean)"/></param>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.FindBuffers(System.Int32,System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            Searches unmanaged memory for pre-existing <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/>s that satisfy
            the given size requirements and address range.
            </summary>
            <param name="size">The amount of bytes a buffer must have minimum.</param>
            <param name="minimumAddress">The maximum pointer a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> can occupy.</param>
            <param name="maximumAddress">The minimum pointer a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> can occupy.</param>
            <param name="useCache">See <see cref="M:Reloaded.Memory.Buffers.Internal.MemoryBufferSearcher.GetBuffers(System.Int32,System.Boolean)"/></param>
            <returns></returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.GetBufferSize(System.Int32,System.Boolean)">
            <summary>
            Calculates the size of a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> to be created for a given requested size
            of raw data, taking into consideration buffer overhead.
            </summary>
            <param name="size">The size of the buffer to be allocated.</param>
            <param name="isPrivateBuffer">Defines whether the buffer type created is a shared or private buffer.</param>
            <returns>A calculated buffer size based off of the requested capacity in bytes.</returns>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferHelper.GetBufferPointerInPageRange(Reloaded.Memory.Buffers.Internal.Kernel32.Kernel32.MEMORY_BASIC_INFORMATION@,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Checks if a buffer can be created within a given set of pages described by pageInfo
            satisfying the given size, minimum and maximum memory location.
            </summary>
            <param name="pageInfo">Contains the information about a singular memory page.</param>
            <param name="bufferSize">The size that a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> would occupy. Pre-aligned to page-size.</param>
            <param name="minimumPtr">The maximum pointer a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> can occupy.</param>
            <param name="maximumPtr">The minimum pointer a <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> can occupy.</param>
            <returns>Zero if the operation fails; otherwise positive value.</returns>
        </member>
        <member name="T:Reloaded.Memory.Buffers.MemoryBufferProperties">
            <summary>
            Contains the individual details of the memory buffer in question.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBufferProperties.DataPointer">
            <summary> The location of the raw data stored in the buffer. </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBufferProperties.Alignment">
            <summary> Specifies the byte alignment of each item that will be added onto the buffer. </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBufferProperties.Offset">
            <summary>Stores the current offset in the buffer, ranging from 0 to <see cref="P:Reloaded.Memory.Buffers.MemoryBufferProperties.Size"/>.</summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBufferProperties.Size">
            <summary>Stores the size of the individual buffer in question.</summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBufferProperties.Remaining">
            <summary> Returns the remaining amount of space in the current buffer (in bytes). </summary>
        </member>
        <member name="P:Reloaded.Memory.Buffers.MemoryBufferProperties.WritePointer">
            <summary> Returns the current write pointer in the buffer. (Address of next element to be written) </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferProperties.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Creates a new <see cref="T:Reloaded.Memory.Buffers.MemoryBufferProperties"/> given the location of the raw data
            and the amount of raw data available at that location.
            </summary>
            <param name="dataPointer">Pointer to raw data (normally following this header).</param>
            <param name="size">The amount of data available at the given pointer, in bytes.</param>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferProperties.SetAlignment(System.Int32)">
            <summary>
            Sets a new alignment (in bytes) for the buffer and auto-aligns the buffer.
            Note that setting the alignment will move the buffer offset to the next multiple of "alignment",
            unless it is already aligned.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryBufferProperties.Align">
            <summary>
            Aligns the buffer offset to its current <see cref="P:Reloaded.Memory.Buffers.MemoryBufferProperties.Alignment"/> value.
            </summary>
        </member>
        <member name="T:Reloaded.Memory.Buffers.MemoryPages">
            <summary>
            Provides various utility methods which allow for the query and retrieval of information regarding individual pages of
            RAM memory.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.MemoryPages.GetPages(System.Diagnostics.Process)">
            <summary>
            Returns a list of pages that exist within a set process' memory.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Reloaded.Memory.Buffers.PrivateMemoryBuffer">
            <summary>
            A type of <see cref="T:Reloaded.Memory.Buffers.MemoryBuffer"/> which cannot be found by others (non-shared) and can be disposed of.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.PrivateMemoryBuffer.Finalize">
            <summary>
            Destroys this object.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Buffers.PrivateMemoryBuffer.Dispose">
            <summary>
            Disposes of the memory used by this buffer.
            </summary>
        </member>
    </members>
</doc>
